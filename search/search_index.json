{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Optimized interpolation routines in Python / numba The library contains: splines.* : fast numba-compatible multilinear and cubic interpolation multilinear.* : fast numba-compatible multilinear interpolation (alternative implementation) smolyak.* : smolyak polynomials complete polynomials install Install latest version: from conda: conda install -c conda-forge interpolation from PyPI: pip install interpolation Latest development version from git: pip install poetry # if not already installed pip install git+https://github.com/econforge/interpolation.py.git/ The project uses a pyproject.toml file instead of setup.py and other legacy configuration files. For those used to development installation, this is feasible using dephell : pip install dephell # if not already installed dephell --from=pyproject.toml --to=setup.py # only once pip install -e . # like old times multilinear and cubic interpolation Fast numba-accelerated interpolation routines for multilinear and cubic interpolation, with any number of dimensions. Several interfaces are provided. eval_linear Preferred interface for multilinear interpolation. It can interpolate on uniform and nonuniform cartesian grids. Several extrapolation options are available. import numpy as np from interpolation.splines import UCGrid, CGrid, nodes # we interpolate function f = lambda x,y: np.sin(np.sqrt(x**2+y**2+0.00001))/np.sqrt(x**2+y**2+0.00001) # uniform cartesian grid grid = UCGrid((-1.0, 1.0, 10), (-1.0, 1.0, 10)) # get grid points gp = nodes(grid) # 100x2 matrix # compute values on grid points values = f(gp[:,0], gp[:,1]).reshape((10,10)) from interpolation.splines import eval_linear # interpolate at one point point = np.array([0.1,0.45]) # 1d array val = eval_linear(grid, values, point) # float # interpolate at many points: points = np.random.random((10000,2)) eval_linear(grid, values, points) # 10000 vector # output can be preallocated out = np.zeros(10000) eval_linear(grid, values, points, out) # 10000 vector ## jitted, non-uniform multilinear interpolation # default calls extrapolate data by using the nearest value inside the grid # other extrapolation options can be chosen among NEAREST, LINEAR, CONSTANT from interpolation.splines import extrap_options as xto points = np.random.random((100,2))*3-1 eval_linear(grid, values, points, xto.NEAREST) # 100 eval_linear(grid, values, points, xto.LINEAR) # 10000 vector eval_linear(grid, values, points, xto.CONSTANT) # 10000 vector # one can also approximate on nonuniform cartesian grids grid = CGrid(np.linspace(-1,1,100)**3, (-1.0, 1.0, 10)) points = np.random.random((10000,2)) eval_linear(grid, values, points) # 10000 vector # it is also possible to interpolate vector-valued functions in the following way f = lambda x,y: np.sin(x**3+y**2+0.00001)/np.sqrt(x**2+y**2+0.00001) g = lambda x,y: np.sin(x**3+y**2+0.00001)/np.sqrt(x**2+y**2+0.00001) grid = UCGrid((-1.0, 1.0, 10), (-1.0, 1.0, 10)) gp = nodes(grid) # 100x2 matrix mvalues = np.concatenate([ f(gp[:,0], gp[:,1]).reshape((10,10))[:,:,None], g(gp[:,0], gp[:,1]).reshape((10,10))[:,:,None] ],axis=2) # 10x10x2 array points = np.random.random((1000,2)) eval_linear(grid, mvalues, points[:,1]) # 2 elements vector eval_linear(grid, mvalues, points) # 1000x2 matrix out = np.zeros((1000,2)) eval_linear(grid, mvalues, points, out) # 1000x2 matrix # finally, the same syntax can be used to interpolate using cubic splines # one just needs to prefilter the coefficients first # the same set of options apply but nonuniform grids are not supported (yet) f = lambda x,y: np.sin(x**3+y**2+0.00001)/np.sqrt(x**2+y**2+0.00001) grid = UCGrid((-1.0, 1.0, 10), (-1.0, 1.0, 10)) gp = nodes(grid) # 100x2 matrix values = f(gp[:,0], gp[:,1]).reshape((10,10)) # filter values from interpolation.splines import filter_cubic coeffs = filter_cubic(grid, values) # a 12x12 array from interpolation.splines import eval_cubic points = np.random.random((1000,2)) eval_cubic(grid, coeffs, points[:,1]) # 2 elements vector eval_cubic(grid, coeffs, points) # 1000x2 matrix out = np.zeros((1000,2)) eval_cubic(grid, coeffs, points, out) # 1000x2 matrix Remark : the arguably strange syntax for the extapolation option comes from the fact the actualy method called must be determined by type inference. So eval_linear(..., extrap_method='linear') would not work because the type of the last argument is always a string. Instead, we use opts.CONSTANT and opts.LINEAR for instance which have different numba types. Despite what it looks UCGrid and CGRid are not objects but functions which return very simple python structures that is a tuple of its arguments. For instance, ((0.0,1.0, 10), (0.0,1.0,20)) represents a 2d square discretized with 10 points along the first dimension and 20 along the second dimension. Similarly (np.array([0.0, 0.1, 0.3, 1.0]), (0.0, 1.0, 20)) represents a square nonuniformly discretized along the first dimension (with 3 points) but uniformly along the second one. Now type dispatch is very sensitive to the exact types (floats vs ints), (tuple vs lists) which is potentially error-prone. Eventually, the functions UCGrid and CGrid will provide some type check and sensible conversions where it applies. This may change when if a parameterized structure-like object appear in numba. interp Simpler interface. Mimmicks default scipy.interp : mutlilinear interpolation with constant extrapolation. ### 1d grid from interpolation import interp x = np.linspace(0,1,100)**2 # non-uniform points y = np.linspace(0,1,100) # values # interpolate at one point: interp(x,y,0.5) # or at many points: u = np.linspace(0,1,1000) # points interp(x,y,u) object interface This is for compatibility purpose only, until a new jittable model object is found. from interpolation.splines import LinearSpline, CubicSpline a = np.array([0.0,0.0,0.0]) # lower boundaries b = np.array([1.0,1.0,1.0]) # upper boundaries orders = np.array([50,50,50]) # 50 points along each dimension values = np.random.random(orders) # values at each node of the grid S = np.random.random((10**6,3)) # coordinates at which to evaluate the splines # multilinear lin = LinearSpline(a,b,orders,values) V = lin(S) # cubic spline = CubicSpline(a,b,orders,values) # filter the coefficients V = spline(S) # interpolates -> (100000,) array development notes Old, unfair timings: (from misc/speed_comparison.py ) # interpolate 10^6 points on a 50x50x50 grid. Cubic: 0.11488723754882812 Linear: 0.03426337242126465 Scipy (linear): 0.6502540111541748 More details are available as an example notebook (outdated) Missing but available soon: - splines at any order - derivative Feasible (some experiments) - evaluation on the GPU (with numba.cuda) - parallel evaluation (with guvectorize) smolyak interpolation See testfile for examples.","title":"Home"},{"location":"#optimized-interpolation-routines-in-python-numba","text":"The library contains: splines.* : fast numba-compatible multilinear and cubic interpolation multilinear.* : fast numba-compatible multilinear interpolation (alternative implementation) smolyak.* : smolyak polynomials complete polynomials","title":"Optimized interpolation routines in Python / numba"},{"location":"#install","text":"Install latest version: from conda: conda install -c conda-forge interpolation from PyPI: pip install interpolation Latest development version from git: pip install poetry # if not already installed pip install git+https://github.com/econforge/interpolation.py.git/ The project uses a pyproject.toml file instead of setup.py and other legacy configuration files. For those used to development installation, this is feasible using dephell : pip install dephell # if not already installed dephell --from=pyproject.toml --to=setup.py # only once pip install -e . # like old times","title":"install"},{"location":"#multilinear-and-cubic-interpolation","text":"Fast numba-accelerated interpolation routines for multilinear and cubic interpolation, with any number of dimensions. Several interfaces are provided.","title":"multilinear and cubic interpolation"},{"location":"#eval_linear","text":"Preferred interface for multilinear interpolation. It can interpolate on uniform and nonuniform cartesian grids. Several extrapolation options are available. import numpy as np from interpolation.splines import UCGrid, CGrid, nodes # we interpolate function f = lambda x,y: np.sin(np.sqrt(x**2+y**2+0.00001))/np.sqrt(x**2+y**2+0.00001) # uniform cartesian grid grid = UCGrid((-1.0, 1.0, 10), (-1.0, 1.0, 10)) # get grid points gp = nodes(grid) # 100x2 matrix # compute values on grid points values = f(gp[:,0], gp[:,1]).reshape((10,10)) from interpolation.splines import eval_linear # interpolate at one point point = np.array([0.1,0.45]) # 1d array val = eval_linear(grid, values, point) # float # interpolate at many points: points = np.random.random((10000,2)) eval_linear(grid, values, points) # 10000 vector # output can be preallocated out = np.zeros(10000) eval_linear(grid, values, points, out) # 10000 vector ## jitted, non-uniform multilinear interpolation # default calls extrapolate data by using the nearest value inside the grid # other extrapolation options can be chosen among NEAREST, LINEAR, CONSTANT from interpolation.splines import extrap_options as xto points = np.random.random((100,2))*3-1 eval_linear(grid, values, points, xto.NEAREST) # 100 eval_linear(grid, values, points, xto.LINEAR) # 10000 vector eval_linear(grid, values, points, xto.CONSTANT) # 10000 vector # one can also approximate on nonuniform cartesian grids grid = CGrid(np.linspace(-1,1,100)**3, (-1.0, 1.0, 10)) points = np.random.random((10000,2)) eval_linear(grid, values, points) # 10000 vector # it is also possible to interpolate vector-valued functions in the following way f = lambda x,y: np.sin(x**3+y**2+0.00001)/np.sqrt(x**2+y**2+0.00001) g = lambda x,y: np.sin(x**3+y**2+0.00001)/np.sqrt(x**2+y**2+0.00001) grid = UCGrid((-1.0, 1.0, 10), (-1.0, 1.0, 10)) gp = nodes(grid) # 100x2 matrix mvalues = np.concatenate([ f(gp[:,0], gp[:,1]).reshape((10,10))[:,:,None], g(gp[:,0], gp[:,1]).reshape((10,10))[:,:,None] ],axis=2) # 10x10x2 array points = np.random.random((1000,2)) eval_linear(grid, mvalues, points[:,1]) # 2 elements vector eval_linear(grid, mvalues, points) # 1000x2 matrix out = np.zeros((1000,2)) eval_linear(grid, mvalues, points, out) # 1000x2 matrix # finally, the same syntax can be used to interpolate using cubic splines # one just needs to prefilter the coefficients first # the same set of options apply but nonuniform grids are not supported (yet) f = lambda x,y: np.sin(x**3+y**2+0.00001)/np.sqrt(x**2+y**2+0.00001) grid = UCGrid((-1.0, 1.0, 10), (-1.0, 1.0, 10)) gp = nodes(grid) # 100x2 matrix values = f(gp[:,0], gp[:,1]).reshape((10,10)) # filter values from interpolation.splines import filter_cubic coeffs = filter_cubic(grid, values) # a 12x12 array from interpolation.splines import eval_cubic points = np.random.random((1000,2)) eval_cubic(grid, coeffs, points[:,1]) # 2 elements vector eval_cubic(grid, coeffs, points) # 1000x2 matrix out = np.zeros((1000,2)) eval_cubic(grid, coeffs, points, out) # 1000x2 matrix Remark : the arguably strange syntax for the extapolation option comes from the fact the actualy method called must be determined by type inference. So eval_linear(..., extrap_method='linear') would not work because the type of the last argument is always a string. Instead, we use opts.CONSTANT and opts.LINEAR for instance which have different numba types. Despite what it looks UCGrid and CGRid are not objects but functions which return very simple python structures that is a tuple of its arguments. For instance, ((0.0,1.0, 10), (0.0,1.0,20)) represents a 2d square discretized with 10 points along the first dimension and 20 along the second dimension. Similarly (np.array([0.0, 0.1, 0.3, 1.0]), (0.0, 1.0, 20)) represents a square nonuniformly discretized along the first dimension (with 3 points) but uniformly along the second one. Now type dispatch is very sensitive to the exact types (floats vs ints), (tuple vs lists) which is potentially error-prone. Eventually, the functions UCGrid and CGrid will provide some type check and sensible conversions where it applies. This may change when if a parameterized structure-like object appear in numba.","title":"eval_linear"},{"location":"#interp","text":"Simpler interface. Mimmicks default scipy.interp : mutlilinear interpolation with constant extrapolation. ### 1d grid from interpolation import interp x = np.linspace(0,1,100)**2 # non-uniform points y = np.linspace(0,1,100) # values # interpolate at one point: interp(x,y,0.5) # or at many points: u = np.linspace(0,1,1000) # points interp(x,y,u)","title":"interp"},{"location":"#object-interface","text":"This is for compatibility purpose only, until a new jittable model object is found. from interpolation.splines import LinearSpline, CubicSpline a = np.array([0.0,0.0,0.0]) # lower boundaries b = np.array([1.0,1.0,1.0]) # upper boundaries orders = np.array([50,50,50]) # 50 points along each dimension values = np.random.random(orders) # values at each node of the grid S = np.random.random((10**6,3)) # coordinates at which to evaluate the splines # multilinear lin = LinearSpline(a,b,orders,values) V = lin(S) # cubic spline = CubicSpline(a,b,orders,values) # filter the coefficients V = spline(S) # interpolates -> (100000,) array","title":"object interface"},{"location":"#development-notes","text":"Old, unfair timings: (from misc/speed_comparison.py ) # interpolate 10^6 points on a 50x50x50 grid. Cubic: 0.11488723754882812 Linear: 0.03426337242126465 Scipy (linear): 0.6502540111541748 More details are available as an example notebook (outdated) Missing but available soon: - splines at any order - derivative Feasible (some experiments) - evaluation on the GPU (with numba.cuda) - parallel evaluation (with guvectorize)","title":"development notes"},{"location":"#smolyak-interpolation","text":"See testfile for examples.","title":"smolyak interpolation"},{"location":"splines/","text":"Splines interpolation Spline interpolation can be performed using two functions prefilter and eval_splines . from interpolation.splines import prefilter, eval_splines These two functions are jit compiled using numba, and should be fast, without big performance loss when used in a loop provided the loop is compiled. The behaviour of these two functions is determined by the type of their argument. In the text below the types provided are numba types obtained using numba.typeof function. grids Splines are defined by their values on a cartesian product of 1-dimensional grids. Regular one dimensional grids , are represented by a Tuple(float64, float64, int64) where first element is the lower bound, the second the upper bound and the latest the number of points. An irregular one dimensional grid , is represented by a numpy array array(float64, 1d, C) . It is assumed to be in increasing order. These are currently supported only for multilinear splines ( k=1 ) A multidimensional grid, is represented as a tuple of one-dimensional grids. For instance, ((0.0, 1.0, 10), (0.0, 1.0, 10)) . Pay attention to one element tuples: (np.array([0.0, 0.1, 0.5])) is not a correct grid (it is one-dimensional). It should be (np.array([0.0, 0.1, 0.5]),) values Given a d-dimensional grid of dimensions n_1 \\times ... \\times n_d n_1 \\times ... \\times n_d . Values to be interpolated can be specified as: a n_1 \\times ... \\times n_d n_1 \\times ... \\times n_d numpy array: scalar values a n_1 \\times ... \\times n_d \\times n_x n_1 \\times ... \\times n_d \\times n_x numpy array: vector values where n_x n_x variables are defined on each node of the grid prefiltering variables For splines of order greater than 1, the coefficients used for interpolation must be prefiltered, for the resulting interpolant to inteporpolate exactly at grid points: C = prefilter(G, V, k=3) where G is a grid and V the values as described above.Currently, prefilter is implemented only for k=3 and k=1 . In the k=1 it does nothing as prefiltering is not required. The coefficient array is of size (n_1+k-1)\\times ... \\times (n_d+k-1) (n_1+k-1)\\times ... \\times (n_d+k-1) for scalar values and (n_1+k-1)\\times ... \\times (n_d+k-1) \\times n_x (n_1+k-1)\\times ... \\times (n_d+k-1) \\times n_x for vector values. Inplace calculations can be performed as: prefilter(G, V, k=3, out=C) Currently, prefiltering cubic splines, always used natural boundaries conditions (f''=0). interpolating the function To interpolate values: eval_spline(G, C, P, out=None, k=3, diff=\"None\", extrap_mode=\"linear\") where: G is a multi-dimensional grid as specified above C an array of coefficients P denotes the locations at which to interpolate: tuple or array of size d : point at which to interpolate 2d array with column size d : list of points at which to interpolate out : if None , interpolated values are returned if array: where to store the result inplace. The dimensions must be exactly equal to the array that would be returned by the function (see below) k: int : spline order (currently (1 or 3)) extrap_mode: str : how to extrapolate outside of the grid. Either: '\"constant\"': 0 outside of the grid '\"nearest\"': takes value from nearest point on the grid '\"linear\"' (default): projects to nearest points and use derivative at this point to extrapolate linearly diff: str : specifies which derivatives to compute '\"None\"': no derivative string representing a tuple of tuple (see below) just in time compilation and literal values In the current eval_spline specification, keyword arguments k , extrap_mode , and diff , are used to control the generation of just in time code and must therefore be known at compile-time. They are ultimately treated as literal values (1 and 3 are of different types for instance.) This currently implies a few limitations: diff must be passed as strings even though it represents a tuple of tuples keyword arguments cannot be ommited. Error message is especially confusing, when they are. there might be a penalty cost in running this function outside of a numba jitted context. It is a known limitation in numba ~0.50, which will ultimately go away specifying partial derivatives Provided the interpolated function f(x) f(x) is defined on a d dimensional space, with arguments $x_1, ... x_d$ . A partial derivative of any order (\\partial^{k_1} ... \\partial^{k_d}) (\\partial^{k_1} ... \\partial^{k_d}) is denoted by d-element tuple (k_1, ..., k_d) . The partial derivatives to be computed by eval_spline can be specified as a tuple of tuples. For instance, in a two dimensional space, to compute the value and the jacobian, one can pass: ( (0,0), (1,0), (0,1) ) Note that we don't pass the tuple directly to eval_spline but a string. For the same example we would then pass: \"( (0,0), (1,0), (0,1) )\" dimensions of the output Depending on the the type of arguments, the output (or the supplied array to perform inplace operations will have different dimensions). Here is a summary. When relevant n_x denotes the number of approximated variable (for vector valued interpolation), N the number of points where the interpolant is approximated (for vectorized operations), n_j the number of partial derivatives to evaluate. Vectorized Vector Valued Derivatives Output no no no float (no inplace) no n_x no n_x array N no no N array N n_x no N.n_x array no no n_j n_j tuple (no inplace) no n_x n_j n_x.n_j array N no n_j N . n_j array N n_x n_j N.n_x.n_j array","title":"Splines"},{"location":"splines/#splines-interpolation","text":"Spline interpolation can be performed using two functions prefilter and eval_splines . from interpolation.splines import prefilter, eval_splines These two functions are jit compiled using numba, and should be fast, without big performance loss when used in a loop provided the loop is compiled. The behaviour of these two functions is determined by the type of their argument. In the text below the types provided are numba types obtained using numba.typeof function.","title":"Splines interpolation"},{"location":"splines/#grids","text":"Splines are defined by their values on a cartesian product of 1-dimensional grids. Regular one dimensional grids , are represented by a Tuple(float64, float64, int64) where first element is the lower bound, the second the upper bound and the latest the number of points. An irregular one dimensional grid , is represented by a numpy array array(float64, 1d, C) . It is assumed to be in increasing order. These are currently supported only for multilinear splines ( k=1 ) A multidimensional grid, is represented as a tuple of one-dimensional grids. For instance, ((0.0, 1.0, 10), (0.0, 1.0, 10)) . Pay attention to one element tuples: (np.array([0.0, 0.1, 0.5])) is not a correct grid (it is one-dimensional). It should be (np.array([0.0, 0.1, 0.5]),)","title":"grids"},{"location":"splines/#values","text":"Given a d-dimensional grid of dimensions n_1 \\times ... \\times n_d n_1 \\times ... \\times n_d . Values to be interpolated can be specified as: a n_1 \\times ... \\times n_d n_1 \\times ... \\times n_d numpy array: scalar values a n_1 \\times ... \\times n_d \\times n_x n_1 \\times ... \\times n_d \\times n_x numpy array: vector values where n_x n_x variables are defined on each node of the grid","title":"values"},{"location":"splines/#prefiltering-variables","text":"For splines of order greater than 1, the coefficients used for interpolation must be prefiltered, for the resulting interpolant to inteporpolate exactly at grid points: C = prefilter(G, V, k=3) where G is a grid and V the values as described above.Currently, prefilter is implemented only for k=3 and k=1 . In the k=1 it does nothing as prefiltering is not required. The coefficient array is of size (n_1+k-1)\\times ... \\times (n_d+k-1) (n_1+k-1)\\times ... \\times (n_d+k-1) for scalar values and (n_1+k-1)\\times ... \\times (n_d+k-1) \\times n_x (n_1+k-1)\\times ... \\times (n_d+k-1) \\times n_x for vector values. Inplace calculations can be performed as: prefilter(G, V, k=3, out=C) Currently, prefiltering cubic splines, always used natural boundaries conditions (f''=0).","title":"prefiltering variables"},{"location":"splines/#interpolating-the-function","text":"To interpolate values: eval_spline(G, C, P, out=None, k=3, diff=\"None\", extrap_mode=\"linear\") where: G is a multi-dimensional grid as specified above C an array of coefficients P denotes the locations at which to interpolate: tuple or array of size d : point at which to interpolate 2d array with column size d : list of points at which to interpolate out : if None , interpolated values are returned if array: where to store the result inplace. The dimensions must be exactly equal to the array that would be returned by the function (see below) k: int : spline order (currently (1 or 3)) extrap_mode: str : how to extrapolate outside of the grid. Either: '\"constant\"': 0 outside of the grid '\"nearest\"': takes value from nearest point on the grid '\"linear\"' (default): projects to nearest points and use derivative at this point to extrapolate linearly diff: str : specifies which derivatives to compute '\"None\"': no derivative string representing a tuple of tuple (see below)","title":"interpolating the function"},{"location":"splines/#just-in-time-compilation-and-literal-values","text":"In the current eval_spline specification, keyword arguments k , extrap_mode , and diff , are used to control the generation of just in time code and must therefore be known at compile-time. They are ultimately treated as literal values (1 and 3 are of different types for instance.) This currently implies a few limitations: diff must be passed as strings even though it represents a tuple of tuples keyword arguments cannot be ommited. Error message is especially confusing, when they are. there might be a penalty cost in running this function outside of a numba jitted context. It is a known limitation in numba ~0.50, which will ultimately go away","title":"just in time compilation and literal values"},{"location":"splines/#specifying-partial-derivatives","text":"Provided the interpolated function f(x) f(x) is defined on a d dimensional space, with arguments $x_1, ... x_d$ . A partial derivative of any order (\\partial^{k_1} ... \\partial^{k_d}) (\\partial^{k_1} ... \\partial^{k_d}) is denoted by d-element tuple (k_1, ..., k_d) . The partial derivatives to be computed by eval_spline can be specified as a tuple of tuples. For instance, in a two dimensional space, to compute the value and the jacobian, one can pass: ( (0,0), (1,0), (0,1) ) Note that we don't pass the tuple directly to eval_spline but a string. For the same example we would then pass: \"( (0,0), (1,0), (0,1) )\"","title":"specifying partial derivatives"},{"location":"splines/#dimensions-of-the-output","text":"Depending on the the type of arguments, the output (or the supplied array to perform inplace operations will have different dimensions). Here is a summary. When relevant n_x denotes the number of approximated variable (for vector valued interpolation), N the number of points where the interpolant is approximated (for vectorized operations), n_j the number of partial derivatives to evaluate. Vectorized Vector Valued Derivatives Output no no no float (no inplace) no n_x no n_x array N no no N array N n_x no N.n_x array no no n_j n_j tuple (no inplace) no n_x n_j n_x.n_j array N no n_j N . n_j array N n_x n_j N.n_x.n_j array","title":"dimensions of the output"}]}